<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet"> 
    <link rel="stylesheet" href="./style/reset.css">
    <link rel="stylesheet" href="./style/style.css">
</head>
<body>
   <div class="wrapper">
        <h1 class="title">Архитектура приложения OptiFlow</h1>
        <h2 class="title">Функциональность, цели, задачи</h2>
        <p class="common-text">Приложение нацелено на оптимизацию маршрутов, построенных по заранее заданным участкам. Подобная оптимизация полезна в любой сфере, прямо или косвенно связанной с логистикой. В частности, будет полезно коммунальным службам для составления маршрутов уборки снега.</p>
        <p class="common-text">С точки зрения пользователя, приложению нужно показать на карте набор точек/участков, через которые необходимо проложить маршрут, а оно, в свою очередь, составит наиболее близкий к кратчайшему маршрут.</p>
        <p class="common-text">Почему наиболее близкий? Дело в том, что задача поиска пути через неопределенное количество точек называется np-трудной. Это означает, что чтобы получить точное решение, необходимо проверить все возможные варианты. Число вариантов растет столь стремительно, что при наличии всего 10 точек маршрута, существует уже 181440 вариантов, а для 20 точек - 60'822'550'204'416'000. Перебирать такое большое число возможных вариантов невероятно долго даже для современных компьютеров, поэтому все алгоритмы, решающие эту задачу за разумное время, эвристические, т.е. работают с определенной точностью и вероятностью. Так, основной алгоритм, используемый в нашей реализации - муравьиный - на тестовых наборах показывает среднее отклонение результата в 3-4% от оптимального, что все еще очень точно. Особенно если сравнить с точностью решения такой задачи человеком (жадный алгоритм - алгоритм, который на каждом шаге будет выбирать кратчайшую дорогу до следующей точки - дает в среднем 30% погрешности).</p>
        <h2 class="title">Архитектура приложения</h2>
        <p class="common-text">В ходе дизайна архитектуры приложения необходимо было добиться максимальной гибкости результата, т.к. на начальном этапе очень часто возникает ситуация, когда необходимо добавить/изменить/удалить функционал. По этой причине все второстепенные решения (например, реализация пользовательского интерфейса) откладываются до того момента, пока в них не появится необходимость. Отложены такие решения, как: 1) будет ли приложение работать целиком на клиенте или сохранение данных и вычисление будет реализовано на сервере; 2) как именно искать и заполнять данные карты, необходимые для работы приложения; 3) каким образом пользовательский интерфейс будет предоставлять управление приложением. Все это является скорее инфраструктурой и не играет решающей роли, пока нет реализации эффективного алгоритма поиска пути.</p>
        <p class="common-text">Что позволяет получить подобную гибкость? Модульная система, где каждый модуль максимально изолирован от логики всех остальных элементов системы и решает только одну конкретную задачу (Единственная ответственность). Чтобы такие модули были независимы также от того, работают ли они целиком на машине клиента или распределены по нескольким компьютерам в сети, они должны быть реализованы как самостоятельные приложения, работающие по сетевым протоколам.</p>
        <p class="common-text">Чтобы удовлетворить всем вышеперечисленным требованиям, было принято решение разбить систему на следующие модули:</p>
        <ul class="table-of-content">
            <li><a href="#GraphSourceManager">Graph Source Manager Socket Server</a> - socket server, работающий по протоколу TCP, отвечает за хранение и предоставление данных карты</li>
            <li><a href="#PathFinder">Path Finder Socket Server</a> - socket server, работающий по протоколу TCP, отвечает за поиск оптимального пути на полученном графе с заданными параметрами</li>
            <li><a href="#ClientController">Client Interaction Controller</a> - часть клиентского приложения, осуществляющая связующую работу между остальными модулями</li>
            <li><a href="#UI">UI</a> - часть клиентского приложения, отвечающая за взаимодействие пользователя с системой</li>
            <li><a href="#PathHolder">Path Holder HTTP server (?optional)</a> - http server, решающий задачу сохранения и передачи уже найденных маршрутов</li>
        </ul>
   </div>
   <div class="structure-illustration">
        <div class="ui-controller"></div>
        <div class="module path-finder">
            <h3>Path Finder</h3>
        </div>
        <div class="module graph-source">
            <h3>Graph Source Manager</h3>
        </div>
        <div class="module controller">
            <h3>Controller</h3>
        </div>
        <div class="module ui">
            <h3>UI</h3>
        </div>
        <div class="module path-server">
            <h3>Path Server</h3>
        </div>
        <div class="arrow between-controller-and-path-finder">
            <div class="point left"></div>
            <div class="line"></div>
            <div class="point right"></div>
        </div>
        <div class="arrow between-contoller-and-graph-data">
            <div class="point left"></div>
            <div class="line"></div>
            <div class="point right"></div>
        </div>
        <div class="vertical-arrow between-controller-and-ui">
            <div class="point top"></div>
            <div class="line"></div>
            <div class="point bottom"></div>
        </div>
        <div class="vertical-arrow between-controller-and-path-server">
            <div class="point top"></div>
            <div class="line"></div>
            <div class="point bottom"></div>
        </div>
        <div class="illustration-info">Модули и отношения OptiFlow</div>
   </div>
   <div class="wrapper">
       <p class="common-text">
           Взаимосвязи между модулями изображены на иллюстрации "Модули и отношения OptiFlow". Как видно из иллюстрации, модули поиска пути и хранения данных карты ничего не знают о других модулях, они только реализуют протокол взаимодействия. Такая слабая связность позволяет как развернуть их на клиенте, обеспечив автономную работу и сэкономив на обслуживании серверов, так и разместить их на серверах.  
       </p>
       <h2 class="title">Подробнее о модулях:</h2>
       <h3 class="title" id="GraphSourceManager">Graph Source Manager</h3>
       <p class="common-text">
           Graph Source Manager - модуль обработки данных карты. Данный модуль решает задачу хранения данных и преобразования в различные форматы. Предполагается, что он содержит базу данных карты, основанную на <a href="https://www.openstreetmap.org/about">Open Street Map</a>, и, возможно, какие-то наши дополнения (например, среднее количество высыпаемой смеси на участок улицы). Данных должно быть достаточно как для визуализации в UI контроллера, так и для поиска пути в Path Finder. При этом модуль берет на себя задачу преобразования данных к формату, приемлимому для работы модуля-клиента, а также обратного преобразования.
       </p>
       <p class="common-text">
           Рекомендации по архитектуре: так как точные контракты взаимодействия модуля с контроллером (равно как и возможные изменения/дополнения) на данном этапе не определены, а реализацию следует начать в кратчайшие сроки, то структурно модуль должен быть <span class="stroked">толерантным к внесению правок</span> многослойным, причем реализацию нужно начать с тех слоев, изменения в которых потенциально маловероятны. </p>
        </p>
        <p class="common-text">Опишем слои снизу вверх: на самом нижнем уровне лежит слой работы с базой данных графа, который должен быть легко расширяем для введения новых хранимых параметров графа. Вводить параметры можно, например, с помощью новых таблиц, содержащих элементы, ассоциированные с элементами уже имеющихся таблиц.
             Над этим уровнем должны лежать адаптеры для каждого вида запросов, а также обработчики запросов определенного типа. Первые обрабатывают запрос к данным графа и
             выдают вызывающей стороне данные во внутреннем формате данных модуля. Вторые переводят данные из формата базы данных в формат ответа на запрос, отправленный клиентом
             (очевидно, что на каждый тип запроса необходим свой адаптер). Адаптеры должны быть взаимозаменяемы относительно более высокого слоя. Разделение обработки запроса 
             на 2 независимые службы - обработчик запроса определенного типа и адаптер данных - нужно, чтобы отделить логику формирования ответа от логики приведения 
             ответа к требуемому формату. В свою очередь это нужно, чтобы редактировать их отдельно и, в случае правок, затрагивающих только один аспект (например изменение 
             формата данных), их внесение не затрагивало реализацию другого. Следующий слой - обработчик запроса клиента. На этом слое необходимо понять, какой запрос отправил 
             клиент, и передать запрос и параметры обработчику запроса определенного типа, а его ответ передать в соответствующий адаптер (при необходимости, эту логику можно вынести в отдельный подслой). Самый верхний слой - слой сервера. Этот слой слушает порт и создает подключения для клиентов, после чего для каждого нового клиента создает поток с обработчиком запроса и передает запрос клиента обработчику, после окончания работы которого отправляет ответ на клиент.

       <h3 class="title" id="PathFinder">Path Finder</h3>
       <p class="commmon-text">
            Path Finder - модуль поика путей. На текущем этапе нацелен на поиск кратчайшего пути, проходящего через n точек на графе дорог города, однако ввиду того, что модуль, по факту, представляет собой коллекцию алгоритмов с доступом по сети, его функционал может быть дополнен и расширен.
       </p>
       <p class="common-text">Структурно, модуль представляет собой набор слоев: <ul><li>Слой обработки соединения</li><li>Слой обработки запроса</li></ul>При кажущейся простоте (всего два слоя), сложность скрывается в реализации логики обработки запроса и работы алгоритмов.</p>
       <p class="common-text">Рассмотрим логику обработки единственного на данном этапе запроса: запроса кратчайшего пути через n точек в графе. Обработка рассматривается с точки зрения архитектуры приложения, алгоритмическая сторона задачи подробнее обсуждается <a href="./about-algorithm/index.html">здесь</a>. Обработчик запроса получает граф и список целевых точек, из которых строит Исходный граф. После этого запускается процесс построения Оптимального графа, где сначала строится матрица кратчайших расстояний (и путей) между целевыми точками с помощью алгоритма Дейкстры, а затем происходит <a href="#conflict-resoluting">разрешение конфликтов</a>, подробнее о котором будет сказано далее. После того, как Оптимальный граф построен, он передается на обработку алгоритмам поиска кратчайшего пути. <a href="#algorithm-chooser">Логика выбора алгоритма</a> поиска кратчайшего пути будет описана далее. Т.к. сами алгоритмы поиска кратчайшего пути работают в отдельных потоках, то основной поток обработки запроса не блокируется и способен обрабатывать <a href="#meta-queries">мета-запросы</a> от клиента, а также отправлять обновления с промежуточными результатами - субоптимальными путями, найденными на момент времени работы алгоритма x.</p>
       <p class="common-text" id="conflict-resoluting"><b>Обработка конфликтов</b> - проблема, возникающая тогда, когда кратчайший путь из одной Красной Точки в другую Красную Точку включает в себя промежуточное Красное ребро и некоторые другие ребра графа. В такой ситуации Оптимальный граф нуждается в предобработке, иначе алгоритм, работающий на Оптимальном графе, будет давать стабильно плохие решения. Над алгоритмом разрешения конфликтов на данный момент ведется работа, однако самым "интуитивно верным" и простым решением конфликта видится удаление конфликтных ребер из оптимального графа.</p>
       <p class="common-text" id="algorithm-chooser"><b>Логика выбора алгоритмов</b> нужна ввиду того, что, в зависимости от сложности оптимального графа, некоторые алгоритмы имеют преимущество над другими. Например, в случае, когда в графе не более 8ми вершин, наилучший ответ можно получить простым перебором всех вариантов за разумное время.</p>
       <p class="common-text" id="meta-queries"><b>Мета-запросы</b> - запросы, касающиеся статуса работы алгоритма. Поддерживаемые запросы: <ul><li>Принудительное завершение работы алгоритма</li><li>Приостановка работы алгоритма</li><li>Получение промежуточных результатов работы алгоритма</li><li>Возобновление работы алгоритма</li></ul></p>
       <h3 class="title" id="ClientController">Client Interaction Controller</h3>
       <p class="common-text">Client Interaction Controller отвечает за взаимодействие пользователя с инфраструктурой приложения. Обрабатывая действия пользователя в UI, контроллер генерирует запросы к модулям и передает между ними данные, отображая результат своей работы пользователю в UI. Детали реализации этого модуля на данном этапе жизни проекта не существенны, однако очевидно, что этот модуль и модуль UI - части единого клиентского приложения и Socket-client-ы для модулей поиска пути и обработки данных графа.</p>
       <h3 class="title" id="UI">UI</h3>
       <p class="common-text">UI - модуль в составе клиентского приложения, реализующий интерфейс взаимодействия пользователя с приложением (рисует карту, показывает элементы управления и т.д.), и передает команды пользователя в контроллер. Детали реализации этого модуля на данный момент также не существенны и будут рассмотрены позднее.</p>
       <h3 class="title" id="PathHolder">Path Holder HTTP Server</h3>
       <p class="common-text">Path Holder HTTP Server - сервер, являющейся необходимой частью инфраструктуры для облачного сохранения результатов работы приложения. Предполагается, что после того, как путь будет сгенерирован, его можно будет сохранить на этом сервере и получить ассоциированный ключ. Ключ после этого можно будет передать исполнителям работы, которые смогут зайти в мобильное приложение и по ключу получить маршрут. В будущем модуль со столь примитивной логикой может быть заменен/расширен с помощью добавления пользователей и групп пользователей, однако на данном этапе эта проблема остается несущественной.</p>
   </div>
</body>
</html>